#!/usr/bin/env ruby

$:.unshift(File.dirname(__FILE__))

require 'rubygems'
require 'pathname'
require 'logging'
require 'trollop'
require 'extlib'
require 'pp'
require 'mq'

require '../daemonize'
require 'queue_wrapper'

include Daemonize

class Agency
  def initialize(base_path)
    @base_path = base_path
    @agents_managed = []

    rails_env = (ENV['RAILS_ENV'].nil?) ? 'development' : ENV['RAILS_ENV']
    Logging.configure(AppConfig.app_root + "/config/logging/#{rails_env}.yml")
    @logger = Logging::Logger['audit']
  end

  def setup_signal_handlers
    %w{INT TERM QUIT}.each do |sig|
      trap sig, lambda { AMQP.stop { EM.stop; puts "Shutting down"; exit } }
    end
  end

  def setup_queue_handlers
    # Set up queue to manage new agents
    RubyMAS::Messaging.new(:manage, :durable => false).receive_message do |header, agent|
      begin
        start_agent(agent)
        @agents_managed << agent unless @agents_managed.include?(agent)
      rescue RuntimeError => e
        @logger.error(e)
        @logger.error("Cannot load agent: #{agent}")
      end
    end

    RubyMAS::Messaging.new(:agents_shutdown, :durable => false).receive_message do |header, message|
      if message == 'all'
        agents_to_terminate = @agents_managed
      else
        if @agents_managed.include?(message)
          agents_to_terminate = [message]
        else
          agents_to_terminate = []
          @logger.error("Cannot kill agent #{message}, it doesn't exist.")
        end
      end

      agents_to_terminate.each do |agent|
        if PIDFileUtilities.process_exists?(agent)
          # Make sure the restart agent is not monitoring the agent.
          RubyMAS::Messaging.new(:unmonitor, :durable => false).send_message(agent)
          @logger.info("Sending kill message to #{agent}")
          RubyMAS::Messaging.new("agent.#{agent.snake_case}", :durable => false).send_message("kill")
        end
      end
    end
  end

  def logger
  end
  private

  def start_agent(agent)
    if PIDFileUtilities.process_exists?(agent)
      @logger.error("Not starting: #{agent}. Agent already exists")
    else
      pid = fork do
        # Detach from the controlling terminal
        unless sess_id = Process.setsid
          raise 'Cannot detach from controlled terminal'
        end

        # Close all file descriptors apart from stdin, stdout, stderr
        ObjectSpace.each_object(IO) do |io|
          unless [STDIN, STDOUT, STDERR].include?(io)
            io.close rescue nil
          end
        end

        # Sort out the remaining file descriptors. Don't do anything with
        # stdout (and by extension stderr) as want the agency to manage it.
        STDIN.reopen("/dev/null")
        STDERR.reopen(STDOUT)

        @logger.info("Starting: #{agent}")
        exec('/usr/bin/ruby', 'agent_bootstrap.rb', @base_path, agent)
      end
      # We don't want any zombies.
      Process.detach(pid)
    end
  end
end

include Daemonize

opts = Trollop::options do
  opt :daemon, "daemonise", :default => false
  opt :logging, "turn amqp logging on", :default => false
  opt :agents_dir, "agents-dir", :type => :string, :required => true
end

agents_to_start = ARGV

unless agents_to_start.empty?
  puts "Starting Agents:\n%s\n" % agents_to_start.inject("") {|str,a| str << "  #{a}\n" }
end

daemonize if opts[:daemon] == true

EM.epoll
EM.run do
  AMQP.logging = true if opts[:logging]

  agency = Agency.new("/home/rgh/dev/rails/pn/lib/amqp/agents")

  agency.setup_signal_handlers
  agency.setup_queue_handlers

  agents_to_start.each do |agent|
    RubyMAS::Messaging.new(:manage, :durable => false).send_message(agent)
  end
end
